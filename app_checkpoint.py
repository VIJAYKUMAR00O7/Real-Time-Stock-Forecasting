# -*- coding: utf-8 -*-
"""app-checkpoint.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o-okw0K9cspLscrd18nMDLAGZk-fpX74
"""

pip install statsmodels

pip install streamlit

pip install yfinance

pip install pandas

pip install numpy

pip install plotly

pip install numpy pandas yfinance streamlit plotly --no-cache-dir

!pip install scikit-learn

pip install xgboost

# -----------------------------------------------------------
#  ðŸ“ˆ Real-Time Market Price Forecasting
#      (LSTM + XGBoost + ARIMA)
# -----------------------------------------------------------

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

# ML / DL
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import xgboost as xgb

# Statsmodels for ARIMA
import statsmodels.api as sm

# -----------------------------------------------------------
# Page Config & Custom CSS
# -----------------------------------------------------------
st.set_page_config(layout="wide", page_title="Market Forecasting Dashboard")

# Custom CSS for enhanced styling
st.markdown("""
<style>
    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        margin: 0.5rem 0;
    }
    .bullish { color: #00C851 !important; font-weight: bold; }
    .bearish { color: #FF4444 !important; font-weight: bold; }
    .neutral { color: #33b5e5 !important; font-weight: bold; }
    .alert-box {
        padding: 1rem;
        border-radius: 8px;
        margin: 1rem 0;
        border-left: 5px solid;
    }
    .alert-success { background-color: #d4edda; border-color: #28a745; }
    .alert-warning { background-color: #fff3cd; border-color: #ffc107; }
    .alert-danger { background-color: #f8d7da; border-color: #dc3545; }
</style>
""", unsafe_allow_html=True)

st.title("ðŸ“ˆ Real-Time Market Price Forecasting Dashboard")
st.markdown("*Advanced AI-Powered Stock Prediction with LSTM, XGBoost & ARIMA*")

# -----------------------------------------------------------
# Sidebar â€“ Enhanced Inputs
# -----------------------------------------------------------
st.sidebar.header("ðŸ“Š Configuration")

# Stock selection with popular options
popular_stocks = {
    "TATAMOTORS.NS": "Tata Motors",
    "RELIANCE.NS": "Reliance Industries",
    "TCS.NS": "Tata Consultancy Services",
    "INFY.NS": "Infosys",
    "HDFCBANK.NS": "HDFC Bank",
    "AAPL": "Apple Inc.",
    "MSFT": "Microsoft Corp.",
    "GOOGL": "Alphabet Inc.",
    "TSLA": "Tesla Inc."
}

stock_option = st.sidebar.selectbox(
    "Select Stock:",
    options=list(popular_stocks.keys()),
    format_func=lambda x: f"{x} - {popular_stocks[x]}",
    index=0
)

custom_ticker = st.sidebar.text_input("Or Enter Custom Symbol:", "")
ticker = custom_ticker if custom_ticker else stock_option

start_date = st.sidebar.date_input("Start Date", datetime(2022, 1, 1))
forecast_days = st.sidebar.slider("Days to Predict", 1, 30, 5)

# Alert System
st.sidebar.subheader("ðŸš¨ Price Alerts")
alert_enabled = st.sidebar.checkbox("Enable Price Alerts")
if alert_enabled:
    alert_upper = st.sidebar.number_input("Alert if price goes above:", value=700.0, step=10.0)
    alert_lower = st.sidebar.number_input("Alert if price goes below:", value=600.0, step=10.0)

# Display options
st.sidebar.subheader("ðŸ“ˆ Display Options")
show_confidence = st.sidebar.checkbox("Show Confidence Intervals", True)
chart_theme = st.sidebar.selectbox("Chart Theme", ["plotly", "plotly_white", "plotly_dark"], index=1)
chart_height = st.sidebar.slider("Chart Height", 300, 600, 400)

# -----------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------
def get_trend_indicator(current, previous):
    """Get trend direction with color and arrow"""
    if current > previous:
        return "ðŸ“ˆ", "bullish", (current - previous) / previous * 100
    elif current < previous:
        return "ðŸ“‰", "bearish", (current - previous) / previous * 100
    else:
        return "âž¡ï¸", "neutral", 0

def calculate_support_resistance(df, window=20):
    """Calculate support and resistance levels"""
    highs = df['Close'].rolling(window=window).max()
    lows = df['Close'].rolling(window=window).min()

    resistance = highs.iloc[-window:].max()
    support = lows.iloc[-window:].min()

    return support, resistance

def get_model_confidence(predictions_df):
    """Calculate confidence scores for each model"""
    volatility = predictions_df.std()
    max_vol = volatility.max()

    # Inverse relationship: lower volatility = higher confidence
    confidence = {}
    for col in predictions_df.columns:
        if 'Prediction' in col:
            model_name = col.replace('_Prediction', '')
            conf_score = max(0, 100 - (volatility[col] / max_vol * 100))
            confidence[model_name] = min(100, conf_score)

    return confidence

def generate_trading_signal(consensus_trend, confidence_avg, volatility):
    """Generate trading recommendations"""
    if confidence_avg >= 70:
        if consensus_trend > 2:
            return "ðŸŸ¢ STRONG BUY", "alert-success"
        elif consensus_trend > 0.5:
            return "ðŸŸ¢ BUY", "alert-success"
        elif consensus_trend < -2:
            return "ðŸ”´ STRONG SELL", "alert-danger"
        elif consensus_trend < -0.5:
            return "ðŸ”´ SELL", "alert-danger"
        else:
            return "ðŸŸ¡ HOLD", "alert-warning"
    else:
        return "âšª UNCERTAIN - Low Confidence", "alert-warning"

# -----------------------------------------------------------
# Load data with error handling and info display
# -----------------------------------------------------------
@st.cache_data
def load_data(ticker, start_date):
    try:
        df = yf.download(ticker,
                         start=start_date,
                         end=pd.to_datetime("today").strftime('%Y-%m-%d'))
        if df.empty:
            st.error(f"No data found for ticker: {ticker}")
            return None
        df = df[['Close']].dropna()
        df.columns = df.columns.droplevel(1)
        return df
    except Exception as e:
        st.error(f"Error loading data: {str(e)}")
        return None

# Display loading message
with st.spinner(f'Loading data for {ticker}...'):
    df = load_data(ticker, start_date)

if df is None or df.empty:
    st.stop()

# Calculate support/resistance and trends
support, resistance = calculate_support_resistance(df)
current_price = df['Close'].iloc[-1]
previous_price = df['Close'].iloc[-2] if len(df) > 1 else current_price
trend_arrow, trend_class, trend_pct = get_trend_indicator(current_price, previous_price)

# Enhanced Stock Info Display
st.markdown("### ðŸ“Š Market Overview")
col1, col2, col3, col4, col5 = st.columns(5)

with col1:
    st.markdown(f"""
    <div class="metric-card">
        <h4>Current Price</h4>
        <h2>â‚¹{current_price:.2f}</h2>
        <p>{trend_arrow} <span class="{trend_class}">{trend_pct:+.2f}%</span></p>
    </div>
    """, unsafe_allow_html=True)

with col2:
    change = current_price - previous_price
    st.markdown(f"""
    <div class="metric-card">
        <h4>Daily Change</h4>
        <h2>â‚¹{change:+.2f}</h2>
        <p class="{trend_class}">({trend_pct:+.2f}%)</p>
    </div>
    """, unsafe_allow_html=True)

with col3:
    st.markdown(f"""
    <div class="metric-card">
        <h4>Support Level</h4>
        <h2>â‚¹{support:.2f}</h2>
        <p>ðŸ“Š Key Level</p>
    </div>
    """, unsafe_allow_html=True)

with col4:
    st.markdown(f"""
    <div class="metric-card">
        <h4>Resistance Level</h4>
        <h2>â‚¹{resistance:.2f}</h2>
        <p>ðŸŽ¯ Target</p>
    </div>
    """, unsafe_allow_html=True)

with col5:
    volatility = df['Close'].pct_change().std() * 100
    vol_color = "bearish" if volatility > 3 else "bullish" if volatility < 1.5 else "neutral"
    st.markdown(f"""
    <div class="metric-card">
        <h4>Volatility</h4>
        <h2 class="{vol_color}">{volatility:.2f}%</h2>
        <p>ðŸ“ˆ Risk Level</p>
    </div>
    """, unsafe_allow_html=True)

# Price Alerts Check
if alert_enabled:
    if current_price >= alert_upper:
        st.markdown(f"""
        <div class="alert-box alert-danger">
            ðŸš¨ <strong>PRICE ALERT!</strong> Current price â‚¹{current_price:.2f} is above your alert level of â‚¹{alert_upper:.2f}
        </div>
        """, unsafe_allow_html=True)
    elif current_price <= alert_lower:
        st.markdown(f"""
        <div class="alert-box alert-danger">
            ðŸš¨ <strong>PRICE ALERT!</strong> Current price â‚¹{current_price:.2f} is below your alert level of â‚¹{alert_lower:.2f}
        </div>
        """, unsafe_allow_html=True)

# ############################################################
# LSTM SECTION
# ############################################################
sequence_length = 60

def prepare_lstm_data(df):
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled = scaler.fit_transform(df.values)
    X, y = [], []
    for i in range(sequence_length, len(scaled)):
        X.append(scaled[i - sequence_length:i, 0])
        y.append(scaled[i, 0])
    X, y = np.array(X), np.array(y)
    X = np.reshape(X, (X.shape[0], X.shape[1], 1))
    return X, y, scaler

X_train, y_train, lstm_scaler = prepare_lstm_data(df)

def build_lstm():
    model = Sequential()
    model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
    model.add(Dropout(0.2))
    model.add(LSTM(50))
    model.add(Dropout(0.2))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

lstm_model = build_lstm()
with st.spinner('Training LSTM model...'):
    lstm_model.fit(X_train, y_train, epochs=5, batch_size=32, verbose=0)

def predict_lstm(days):
    seq = lstm_scaler.transform(df[-sequence_length:])
    seq = seq.reshape(1, sequence_length, 1)

    preds = []
    for _ in range(days):
        p = lstm_model.predict(seq, verbose=0)[0][0]
        preds.append(p)
        seq = np.append(seq[:, 1:, :], [[[p]]], axis=1)

    preds = lstm_scaler.inverse_transform(np.array(preds).reshape(-1, 1))
    dates = pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=days, freq='D')
    return pd.DataFrame(preds, index=dates, columns=["LSTM_Prediction"])

lstm_preds = predict_lstm(forecast_days)

# ############################################################
# XGBoost SECTION
# ############################################################
def create_xgb_features(df, lags=[1, 2, 3, 5, 7, 10]):
    feat = df.copy()
    for l in lags:
        feat[f'lag_{l}'] = feat['Close'].shift(l)
    feat['ma_5']  = feat['Close'].rolling(5).mean()
    feat['ma_10'] = feat['Close'].rolling(10).mean()
    return feat.dropna()

def train_xgb(df):
    df_feat = create_xgb_features(df)
    X = df_feat.drop(columns=['Close'])
    y = df_feat['Close']
    model = xgb.XGBRegressor(n_estimators=200,
                             learning_rate=0.05,
                             max_depth=4,
                             subsample=0.8,
                             colsample_bytree=0.8,
                             random_state=42)
    model.fit(X, y)
    return model, X.columns

xgb_model, feat_cols = train_xgb(df)

def predict_xgb(days):
    preds = []
    tmp_df = df.copy()

    for _ in range(days):
        feat_df = create_xgb_features(tmp_df)
        row = feat_df.iloc[-1:][feat_cols]
        p = xgb_model.predict(row)[0]
        preds.append(p)

        new_idx = tmp_df.index[-1] + pd.Timedelta(days=1)
        tmp_df = pd.concat([tmp_df,
                            pd.DataFrame({'Close': p}, index=[new_idx])])

    dates = pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=days, freq='D')
    return pd.DataFrame({'XGBoost_Prediction': preds}, index=dates)

xgb_preds = predict_xgb(forecast_days)

# ############################################################
# ARIMA SECTION
# ############################################################
def fit_arima(df, p=5, d=1, q=0):
    model = sm.tsa.ARIMA(df['Close'], order=(p, d, q))
    model_fit = model.fit()
    return model_fit

arima_model = fit_arima(df)

def predict_arima(days):
    forecast = arima_model.forecast(steps=days)
    dates = pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=days, freq='D')
    return pd.DataFrame({'ARIMA_Prediction': forecast.values}, index=dates)

arima_preds = predict_arima(forecast_days)

# ############################################################
# Performance Metrics & Confidence Scores
# ############################################################
def calculate_metrics(actual, predicted):
    mse = np.mean((actual - predicted) ** 2)
    rmse = np.sqrt(mse)
    mae = np.mean(np.abs(actual - predicted))
    mape = np.mean(np.abs((actual - predicted) / actual)) * 100
    return {'MSE': mse, 'RMSE': rmse, 'MAE': mae, 'MAPE': mape}

def get_model_performance():
    lstm_train_pred = lstm_model.predict(X_train, verbose=0)
    lstm_train_pred = lstm_scaler.inverse_transform(lstm_train_pred)
    lstm_actual = lstm_scaler.inverse_transform(y_train.reshape(-1, 1))
    lstm_metrics = calculate_metrics(lstm_actual.flatten(), lstm_train_pred.flatten())

    return {'LSTM': lstm_metrics}

performance_metrics = get_model_performance()

# Calculate model confidence scores
all_predictions = pd.DataFrame({
    'LSTM_Prediction': lstm_preds['LSTM_Prediction'].values,
    'XGBoost_Prediction': xgb_preds['XGBoost_Prediction'].values,
    'ARIMA_Prediction': arima_preds['ARIMA_Prediction'].values
})

confidence_scores = get_model_confidence(all_predictions)

# ############################################################
# Technical Indicators
# ############################################################
def add_technical_indicators(df):
    df = df.copy()
    df['SMA_20'] = df['Close'].rolling(window=20).mean()
    df['SMA_50'] = df['Close'].rolling(window=50).mean()

    rolling_mean = df['Close'].rolling(window=20).mean()
    rolling_std = df['Close'].rolling(window=20).std()
    df['BB_Upper'] = rolling_mean + (rolling_std * 2)
    df['BB_Lower'] = rolling_mean - (rolling_std * 2)

    delta = df['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))

    return df

df_with_indicators = add_technical_indicators(df)

# ############################################################
# Enhanced Plotly Charts
# ############################################################
def create_enhanced_forecast_chart(historical_df, prediction_df, title, color_scheme):
    fig = go.Figure()

    # Historical data
    fig.add_trace(go.Scatter(
        x=historical_df.index,
        y=historical_df['Close'],
        mode='lines',
        name='Historical',
        line=dict(color=color_scheme['historical'], width=2),
        hovertemplate='Date: %{x}<br>Price: â‚¹%{y:.2f}<extra></extra>'
    ))

    # Predictions
    pred_col = prediction_df.columns[0]
    fig.add_trace(go.Scatter(
        x=prediction_df.index,
        y=prediction_df[pred_col],
        mode='lines+markers',
        name='Forecast',
        line=dict(color=color_scheme['prediction'], width=3, dash='dot'),
        marker=dict(size=8, color=color_scheme['prediction']),
        hovertemplate='Date: %{x}<br>Predicted: â‚¹%{y:.2f}<extra></extra>'
    ))

    # Add support/resistance lines
    fig.add_hline(y=support, line_dash="dash", line_color="green",
                  annotation_text="Support", annotation_position="bottom right")
    fig.add_hline(y=resistance, line_dash="dash", line_color="red",
                  annotation_text="Resistance", annotation_position="top right")

    fig.update_layout(
        title=title,
        template=chart_theme,
        height=chart_height,
        showlegend=True,
        hovermode='x unified',
        xaxis_title="Date",
        yaxis_title="Price (â‚¹)"
    )

    return fig

# ############################################################
# Trading Signals & Analysis
# ############################################################
# Calculate consensus
consensus_pred = all_predictions.mean(axis=1)
consensus_trend = (consensus_pred.iloc[-1] - current_price) / current_price * 100
confidence_avg = np.mean(list(confidence_scores.values()))

# Generate trading signal
trading_signal, signal_class = generate_trading_signal(consensus_trend, confidence_avg, volatility)

# Display Trading Signal
st.markdown("### ðŸŽ¯ AI Trading Recommendation")
st.markdown(f"""
<div class="alert-box {signal_class}">
    <h3>{trading_signal}</h3>
    <p><strong>Consensus Trend:</strong> {consensus_trend:+.2f}%</p>
    <p><strong>Average Confidence:</strong> {confidence_avg:.1f}%</p>
    <p><strong>Risk Level:</strong> {vol_color.title()} Volatility ({volatility:.2f}%)</p>
</div>
""", unsafe_allow_html=True)

# ############################################################
# Streamlit Display â€“ Enhanced Tabs
# ############################################################
tab1, tab2, tab3, tab4, tab5 = st.tabs(["ðŸ”® LSTM", "ðŸš€ XGBoost", "ðŸ“Š ARIMA", "ðŸ“ˆ Technical Analysis", "âš¡ Dashboard"])

color_schemes = {
    'lstm': {'historical': '#1f77b4', 'prediction': '#ff7f0e'},
    'xgboost': {'historical': '#2ca02c', 'prediction': '#d62728'},
    'arima': {'historical': '#9467bd', 'prediction': '#8c564b'}
}

with tab1:
    col1, col2 = st.columns([3, 1])

    with col1:
        st.subheader("ðŸ“ˆ LSTM Deep Learning Forecast")
        lstm_chart = create_enhanced_forecast_chart(df, lstm_preds, "LSTM Neural Network Prediction", color_schemes['lstm'])
        st.plotly_chart(lstm_chart, use_container_width=True)

    with col2:
        st.subheader("Model Performance")
        # Calculate average price for percentage conversion
        avg_price = df['Close'].mean()

        # Convert RMSE and MAE to percentages
        rmse_pct = (performance_metrics['LSTM']['RMSE'] / avg_price) * 100
        mae_pct = (performance_metrics['LSTM']['MAE'] / avg_price) * 100

        st.metric("RMSE", f"{rmse_pct:.2f}%")
        st.metric("MAE", f"{mae_pct:.2f}%")
        st.metric("MAPE", f"{performance_metrics['LSTM']['MAPE']:.2f}%")

        # Confidence Score
        lstm_conf = confidence_scores.get('LSTM', 0)
        conf_color = "ðŸŸ¢" if lstm_conf > 70 else "ðŸŸ¡" if lstm_conf > 50 else "ðŸ”´"
        st.metric("Confidence", f"{conf_color} {lstm_conf:.1f}%")

    st.subheader("LSTM Prediction Values")
    lstm_display = lstm_preds.copy()
    lstm_display['Trend'] = lstm_display['LSTM_Prediction'].pct_change() * 100
    lstm_display['Signal'] = lstm_display['Trend'].apply(lambda x: "ðŸ“ˆ" if x > 0 else "ðŸ“‰" if x < 0 else "âž¡ï¸")
    st.dataframe(lstm_display.round(2), use_container_width=True)

with tab2:
    col1, col2 = st.columns([3, 1])

    with col1:
        st.subheader("ðŸ“Š XGBoost Gradient Boosting Forecast")
        xgb_chart = create_enhanced_forecast_chart(df, xgb_preds, "XGBoost Machine Learning Prediction", color_schemes['xgboost'])
        st.plotly_chart(xgb_chart, use_container_width=True)

    with col2:
        st.subheader("Model Insights")
        xgb_conf = confidence_scores.get('XGBoost', 0)
        conf_color = "ðŸŸ¢" if xgb_conf > 70 else "ðŸŸ¡" if xgb_conf > 50 else "ðŸ”´"
        st.metric("Confidence", f"{conf_color} {xgb_conf:.1f}%")

        st.subheader("Feature Importance")
        importance = xgb_model.feature_importances_
        feat_imp_df = pd.DataFrame({
            'Feature': feat_cols,
            'Importance': importance
        }).sort_values('Importance', ascending=False).head(5)

        for _, row in feat_imp_df.iterrows():
            st.metric(row['Feature'], f"{row['Importance']:.3f}")

    st.subheader("XGBoost Prediction Values")
    xgb_display = xgb_preds.copy()
    xgb_display['Trend'] = xgb_display['XGBoost_Prediction'].pct_change() * 100
    xgb_display['Signal'] = xgb_display['Trend'].apply(lambda x: "ðŸ“ˆ" if x > 0 else "ðŸ“‰" if x < 0 else "âž¡ï¸")
    st.dataframe(xgb_display.round(2), use_container_width=True)

with tab3:
    col1, col2 = st.columns([3, 1])

    with col1:
        st.subheader("ðŸ“‰ ARIMA Time Series Forecast")
        arima_chart = create_enhanced_forecast_chart(df, arima_preds, "ARIMA Statistical Prediction", color_schemes['arima'])
        st.plotly_chart(arima_chart, use_container_width=True)

    with col2:
        st.subheader("Model Insights")
        arima_conf = confidence_scores.get('ARIMA', 0)
        conf_color = "ðŸŸ¢" if arima_conf > 70 else "ðŸŸ¡" if arima_conf > 50 else "ðŸ”´"
        st.metric("Confidence", f"{conf_color} {arima_conf:.1f}%")

        st.subheader("Model Info")
        st.info("ARIMA (5,1,0) Model\nAutoregressive with differencing")

    st.subheader("ARIMA Prediction Values")
    arima_display = arima_preds.copy()
    arima_display['Trend'] = arima_display['ARIMA_Prediction'].pct_change() * 100
    arima_display['Signal'] = arima_display['Trend'].apply(lambda x: "ðŸ“ˆ" if x > 0 else "ðŸ“‰" if x < 0 else "âž¡ï¸")
    st.dataframe(arima_display.round(2), use_container_width=True)

with tab4:
    st.subheader("ðŸ“ˆ Technical Analysis Dashboard")

    # Create technical analysis chart
    fig_tech = make_subplots(rows=3, cols=1,
                            subplot_titles=('Price & Moving Averages', 'Bollinger Bands', 'RSI'),
                            vertical_spacing=0.08,
                            row_heights=[0.5, 0.3, 0.2])

    # Price and Moving Averages
    recent_data = df_with_indicators.tail(100)
    fig_tech.add_trace(go.Scatter(x=recent_data.index, y=recent_data['Close'],
                                 name='Close Price', line=dict(color='blue', width=2)), row=1, col=1)
    fig_tech.add_trace(go.Scatter(x=recent_data.index, y=recent_data['SMA_20'],
                                 name='SMA 20', line=dict(color='orange', width=1)), row=1, col=1)
    fig_tech.add_trace(go.Scatter(x=recent_data.index, y=recent_data['SMA_50'],
                                 name='SMA 50', line=dict(color='red', width=1)), row=1, col=1)

    # Bollinger Bands
    fig_tech.add_trace(go.Scatter(x=recent_data.index, y=recent_data['BB_Upper'],
                                 name='BB Upper', line=dict(color='gray', dash='dash')), row=2, col=1)
    fig_tech.add_trace(go.Scatter(x=recent_data.index, y=recent_data['Close'],
                                 name='Price', line=dict(color='blue')), row=2, col=1)
    fig_tech.add_trace(go.Scatter(x=recent_data.index, y=recent_data['BB_Lower'],
                                 name='BB Lower', line=dict(color='gray', dash='dash')), row=2, col=1)

    # RSI
    fig_tech.add_trace(go.Scatter(x=recent_data.index, y=recent_data['RSI'],
                                 name='RSI', line=dict(color='purple')), row=3, col=1)
    fig_tech.add_hline(y=70, line_dash="dash", line_color="red", row=3, col=1)
    fig_tech.add_hline(y=30, line_dash="dash", line_color="green", row=3, col=1)

    fig_tech.update_layout(height=800, template=chart_theme, showlegend=False)
    st.plotly_chart(fig_tech, use_container_width=True)

    # Technical Analysis Summary
    col1, col2, col3 = st.columns(3)

    current_rsi = df_with_indicators['RSI'].iloc[-1]
    sma_20 = df_with_indicators['SMA_20'].iloc[-1]
    sma_50 = df_with_indicators['SMA_50'].iloc[-1]

    with col1:
        rsi_signal = "ðŸ”´ Overbought" if current_rsi > 70 else "ðŸŸ¢ Oversold" if current_rsi < 30 else "ðŸŸ¡ Neutral"
        st.metric("RSI Signal", rsi_signal, f"{current_rsi:.1f}")

    with col2:
        ma_signal = "ðŸŸ¢ Bullish" if current_price > sma_20 > sma_50 else "ðŸ”´ Bearish" if current_price < sma_20 < sma_50 else "ðŸŸ¡ Mixed"
        st.metric("MA Signal", ma_signal)

    with col3:
        bb_position = "Upper" if current_price > df_with_indicators['BB_Upper'].iloc[-1] else "Lower" if current_price < df_with_indicators['BB_Lower'].iloc[-1] else "Middle"
        st.metric("BB Position", f"ðŸŽ¯ {bb_position}")

with tab5:
    st.subheader("âš¡ Real-time Dashboard")

    # Auto-refresh button
    col1, col2, col3 = st.columns([1, 1, 2])
    with col1:
        if st.button("ðŸ”„ Refresh Data", type="primary"):
            st.cache_data.clear()
            st.rerun()

    with col2:
        auto_refresh = st.checkbox("Auto Refresh (30s)")
        if auto_refresh:
            st.rerun()

    # Real-time metrics with enhanced styling
    st.markdown("#### ðŸ“Š Live Market Metrics")
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        last_update = df.index[-1].strftime("%H:%M")
        st.metric("Last Update", last_update, "Live")

    with col2:
        market_cap = "N/A"  # Would need additional API for real market cap
        st.metric("Market Status", "ðŸŸ¢ Open" if datetime.now().hour < 16 else "ðŸ”´ Closed")

    with col3:
        volume_trend = "ðŸ“ˆ High" if volatility > 2 else "ðŸ“Š Normal"
        st.metric("Activity", volume_trend)

    with col4:
        data_quality = "ðŸŸ¢ Good" if len(df) > 100 else "ðŸŸ¡ Limited"
        st.metric("Data Quality", data_quality, f"{len(df)} points")

    # Recent price movements
    st.markdown("#### ðŸ“ˆ Recent Price Action (Last 10 Days)")
    recent_data = df.tail(10).copy()
    recent_data['Daily_Change'] = recent_data['Close'].pct_change() * 100
    recent_data['Direction'] = recent_data['Daily_Change'].apply(
        lambda x: "ðŸŸ¢" if x > 0 else "ðŸ”´" if x < 0 else "âšª"
    )
    recent_data['Trend_Class'] = recent_data['Daily_Change'].apply(
        lambda x: "bullish" if x > 0 else "bearish" if x < 0 else "neutral"
    )

    # Display recent data with color coding
    st.dataframe(
        recent_data[['Close', 'Daily_Change', 'Direction']].round(2).style.format({
            'Close': 'â‚¹{:.2f}',
            'Daily_Change': '{:+.2f}%'
        }),
        use_container_width=True
    )

# ############################################################
# Enhanced Summary Section with Trading Insights
# ############################################################
st.markdown("---")
st.header("ðŸ“Š Comprehensive AI Analysis")

# Model predictions comparison with enhanced visualization
col1, col2 = st.columns([2, 1])

with col1:
    st.subheader("ðŸ”® All Model Predictions Comparison")

    # Create comparison chart
    fig_comparison = go.Figure()

    # Historical data (last 30 days for context)
    historical_recent = df.tail(30)
    fig_comparison.add_trace(go.Scatter(
        x=historical_recent.index,
        y=historical_recent['Close'],
        mode='lines',
        name='Historical',
        line=dict(color='#1f77b4', width=2),
        hovertemplate='Date: %{x}<br>Price: â‚¹%{y:.2f}<extra></extra>'
    ))

    # Model predictions
    colors = ['#ff7f0e', '#2ca02c', '#d62728']
    models = ['LSTM', 'XGBoost', 'ARIMA']
    predictions = [lstm_preds['LSTM_Prediction'], xgb_preds['XGBoost_Prediction'], arima_preds['ARIMA_Prediction']]

    for i, (model, pred, color) in enumerate(zip(models, predictions, colors)):
        fig_comparison.add_trace(go.Scatter(
            x=pred.index,
            y=pred.values,
            mode='lines+markers',
            name=f'{model} Forecast',
            line=dict(color=color, width=2, dash='dot'),
            marker=dict(size=6),
            hovertemplate=f'{model}: %{{y:.2f}}<extra></extra>'
        ))

    # Add support/resistance lines
    fig_comparison.add_hline(y=support, line_dash="dash", line_color="green",
                           annotation_text="Support â‚¹{:.2f}".format(support))
    fig_comparison.add_hline(y=resistance, line_dash="dash", line_color="red",
                           annotation_text="Resistance â‚¹{:.2f}".format(resistance))

    fig_comparison.update_layout(
        template=chart_theme,
        height=500,
        showlegend=True,
        hovermode='x unified',
        xaxis_title="Date",
        yaxis_title="Price (â‚¹)",
        title="Multi-Model Forecast Comparison"
    )

    st.plotly_chart(fig_comparison, use_container_width=True)

with col2:
    st.subheader("ðŸŽ¯ Model Consensus")

    # Calculate consensus metrics
    avg_prediction = all_predictions.mean(axis=1)
    std_prediction = all_predictions.std(axis=1)

    # Display consensus for each day
    for i, date in enumerate(all_predictions.index):
        trend_arrow = "ðŸ“ˆ" if avg_prediction.iloc[i] > current_price else "ðŸ“‰"
        confidence_level = "High" if std_prediction.iloc[i] < current_price * 0.02 else "Medium" if std_prediction.iloc[i] < current_price * 0.05 else "Low"

        st.markdown(f"""
        **Day {i+1}** {trend_arrow}
        **Price:** â‚¹{avg_prediction.iloc[i]:.2f}
        **Range:** Â±â‚¹{std_prediction.iloc[i]:.2f}
        **Confidence:** {confidence_level}
        ---
        """)

# Model Agreement Analysis with enhanced metrics
st.subheader("ðŸ¤– Model Intelligence Analysis")
col1, col2, col3, col4 = st.columns(4)

# Calculate advanced metrics
agreement_df = all_predictions.copy()
agreement_df['Range'] = agreement_df.max(axis=1) - agreement_df.min(axis=1)
agreement_df['Consensus'] = agreement_df.mean(axis=1)
avg_range = agreement_df['Range'].mean()
max_consensus = agreement_df['Consensus'].max()
trend_direction = "ðŸ“ˆ Bullish" if agreement_df['Consensus'].iloc[-1] > agreement_df['Consensus'].iloc[0] else "ðŸ“‰ Bearish"

# Calculate model agreement score
agreement_score = max(0, 100 - (avg_range / current_price * 100))

with col1:
    st.metric("Avg Prediction Range", f"â‚¹{avg_range:.2f}",
             f"{avg_range/current_price*100:.1f}% of price")

with col2:
    st.metric("Highest Consensus", f"â‚¹{max_consensus:.2f}")

with col3:
    st.metric("Overall Trend", trend_direction)

with col4:
    agreement_color = "ðŸŸ¢" if agreement_score > 80 else "ðŸŸ¡" if agreement_score > 60 else "ðŸ”´"
    st.metric("Agreement Score", f"{agreement_color} {agreement_score:.1f}%")

# Enhanced Risk Assessment with actionable insights
st.subheader("âš ï¸ Risk Assessment & Investment Guidance")
col1, col2, col3 = st.columns(3)

with col1:
    # Volatility risk with actionable advice
    if volatility > 3:
        risk_level = "ðŸ”´ HIGH RISK"
        advice = "Consider smaller position sizes"
    elif volatility > 1.5:
        risk_level = "ðŸŸ¡ MODERATE RISK"
        advice = "Standard position sizing"
    else:
        risk_level = "ðŸŸ¢ LOW RISK"
        advice = "Good for larger positions"

    st.markdown(f"""
    **Volatility Analysis**
    {risk_level}: {volatility:.2f}%
    *{advice}*
    """)

with col2:
    # Model disagreement risk
    if avg_range > current_price * 0.05:
        disagreement_level = "ðŸ”´ HIGH DISAGREEMENT"
        model_advice = "Wait for clearer signals"
    elif avg_range > current_price * 0.02:
        disagreement_level = "ðŸŸ¡ MODERATE DISAGREEMENT"
        model_advice = "Use caution, smaller sizes"
    else:
        disagreement_level = "ðŸŸ¢ GOOD AGREEMENT"
        model_advice = "Models align well"

    st.markdown(f"""
    **Model Consensus**
    {disagreement_level}
    *{model_advice}*
    """)

with col3:
    # Data recency and quality
    days_since_update = (pd.to_datetime("today") - df.index[-1]).days
    if days_since_update > 1:
        data_status = "ðŸŸ¡ DATA AGING"
        data_advice = f"Data is {days_since_update} days old"
    else:
        data_status = "ðŸŸ¢ DATA CURRENT"
        data_advice = "Fresh market data"

    st.markdown(f"""
    **Data Quality**
    {data_status}
    *{data_advice}*
    """)

# Final Investment Summary
st.markdown("---")
st.markdown("### ðŸ’¡ Investment Summary")

# Calculate final recommendation score
recommendation_score = (confidence_avg + agreement_score) / 2
price_target = avg_prediction.iloc[-1]
potential_return = (price_target - current_price) / current_price * 100

if recommendation_score >= 75 and abs(potential_return) > 2:
    if potential_return > 0:
        final_recommendation = "ðŸŸ¢ STRONG BUY SIGNAL"
        recommendation_class = "alert-success"
    else:
        final_recommendation = "ðŸ”´ STRONG SELL SIGNAL"
        recommendation_class = "alert-danger"
elif recommendation_score >= 60:
    if potential_return > 1:
        final_recommendation = "ðŸŸ¢ BUY SIGNAL"
        recommendation_class = "alert-success"
    elif potential_return < -1:
        final_recommendation = "ðŸ”´ SELL SIGNAL"
        recommendation_class = "alert-danger"
    else:
        final_recommendation = "ðŸŸ¡ HOLD POSITION"
        recommendation_class = "alert-warning"
else:
    final_recommendation = "âšª UNCERTAIN - WAIT"
    recommendation_class = "alert-warning"

st.markdown(f"""
<div class="alert-box {recommendation_class}">
    <h2>{final_recommendation}</h2>
    <div style="display: flex; justify-content: space-between; margin-top: 1rem;">
        <div>
            <strong>Target Price:</strong> â‚¹{price_target:.2f}<br>
            <strong>Potential Return:</strong> {potential_return:+.2f}%<br>
            <strong>Time Horizon:</strong> {forecast_days} days
        </div>
        <div>
            <strong>Confidence:</strong> {confidence_avg:.1f}%<br>
            <strong>Agreement:</strong> {agreement_score:.1f}%<br>
            <strong>Overall Score:</strong> {recommendation_score:.1f}%
        </div>
    </div>
</div>
""", unsafe_allow_html=True)

# Key levels for traders
st.markdown("#### ðŸŽ¯ Key Trading Levels")
col1, col2, col3, col4 = st.columns(4)

with col1:
    st.metric("Entry Level", f"â‚¹{current_price:.2f}", "Current")

with col2:
    stop_loss = current_price * 0.95 if potential_return > 0 else current_price * 1.05
    st.metric("Stop Loss", f"â‚¹{stop_loss:.2f}", f"{-5 if potential_return > 0 else 5}%")

with col3:
    st.metric("Target 1", f"â‚¹{price_target:.2f}", f"{potential_return:+.1f}%")

with col4:
    target_2 = price_target * 1.1 if potential_return > 0 else price_target * 0.9
    extended_return = (target_2 - current_price) / current_price * 100
    st.metric("Target 2", f"â‚¹{target_2:.2f}", f"{extended_return:+.1f}%")

pip install tensorflow